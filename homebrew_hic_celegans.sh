#################################
#    in-silico 4C C. elegans    #
#################################

# This script will look in the two sets of chromosome conformation data produced by the Meyer lab (2015 and 2017) and export plots
# that show interaction counts with a specific region of interest (4C analysis). 

# Chromosome conformation data has already been processed using the homebrew pipeline to produce a list of every interaction mapped to 
# their fragment ends.

# Required inputs
#A-Left boundary of region. 
#B-right boundary of region. 
#C-chromosome
#D-binsize
#E-Output directory
#F-Output ID

#Example input for NYU HPC:
##Rscript ~/worms/scripts/insilico_4C.R 11094135 11094136 chrX 10000 /scratch/mrp420/ rex8 > outputFile_1.Rout 2>&1

#Arguments reported to ouptut file.
print('Script started')
Sys.time()
args <- commandArgs(trailingOnly=TRUE)
print(paste0('These are the args:',args))
query_region<-args
query_region[c(1,2,4)]<-as.numeric(query_region[c(1,2,4)])

#Test inputs - used for troubleshooting the script
#query_region<-c(806676,806677,'chrX',10000,'/scratch/mrp420/','rex40')

#Read in the data files - these are the list of fends from the meyer data. These directories are avaliable to members of the Ercan lab.  
#The equivalent files can be generated by running homebrew piepline on the meyer data.

#Intra-chromosomal files first
N2B12015<-read.table('/scratch/cgsb/ercan/GEO/2015_meyer/interactions/N2B12015_intra_fends', stringsAsFactors=F)
N2B22015<-read.table('/scratch/cgsb/ercan/GEO/2015_meyer/interactions/N2B22015_intra_fends', stringsAsFactors=F)
#SDC2B12015<-read.table('/scratch/cgsb/ercan/GEO/2015_meyer/interactions/SDC2B12015_intra_fends', stringsAsFactors=F)
#SDC2B22015<-read.table('/scratch/cgsb/ercan/GEO/2015_meyer/interactions/SDC2B22015_intra_fends', stringsAsFactors=F)

N2B1<-read.table('/scratch/cgsb/ercan/GEO/2017_meyer/interactions/N2B1_intra_fends', stringsAsFactors=F)
N2B2<-read.table('/scratch/cgsb/ercan/GEO/2017_meyer/interactions/N2B2_intra_fends', stringsAsFactors=F)
SDC2B1<-read.table('/scratch/cgsb/ercan/GEO/2017_meyer/interactions/SDC2B1_intra_fends', stringsAsFactors=F)
SDC2B2<-read.table('/scratch/cgsb/ercan/GEO/2017_meyer/interactions/SDC2B2_intra_fends', stringsAsFactors=F)

#Inter-chromosomal files second
N2B12015_inter<-read.table('/scratch/cgsb/ercan/GEO/2015_meyer/interactions/N2B12015_inter_fends', stringsAsFactors=F)
N2B22015_inter<-read.table('/scratch/cgsb/ercan/GEO/2015_meyer/interactions/N2B22015_inter_fends', stringsAsFactors=F)
#SDC2B12015_inter<-read.table('/scratch/cgsb/ercan/GEO/2015_meyer/interactions/SDC2B12015_inter_fends', stringsAsFactors=F)
#SDC2B22015_inter<-read.table('/scratch/cgsb/ercan/GEO/2015_meyer/interactions/SDC2B22015_inter_fends', stringsAsFactors=F)

N2B1_inter<-read.table('/scratch/cgsb/ercan/GEO/2017_meyer/interactions/N2B1_inter_fends', stringsAsFactors=F)
N2B2_inter<-read.table('/scratch/cgsb/ercan/GEO/2017_meyer/interactions/N2B2_inter_fends', stringsAsFactors=F)
SDC2B1_inter<-read.table('/scratch/cgsb/ercan/GEO/2017_meyer/interactions/SDC2B1_inter_fends', stringsAsFactors=F)
SDC2B2_inter<-read.table('/scratch/cgsb/ercan/GEO/2017_meyer/interactions/SDC2B2_inter_fends', stringsAsFactors=F)


##NEED TO CARRY ON WITH INTER. LASTLY MAYBE SORT OUTPUTS SO CREATES A LITTLE DIRECTORY AS SO MANY OUTPUTS. TABLE OUTPUTS AS WELL!


#Ercan lab defined Rex sites are read in for graphing purposes
rex_sites<-read.table('/scratch/cgsb/ercan/Defined_regions/rex_sites', stringsAsFactors=F)
print('Input files opened')

#Define chromosome names and lengths
chr.length <- list("chrI" = 15072423, "chrII" = 15279345, "chrIII" = 13783700, "chrIV" = 17493793, "chrV" = 20924149, "chrX" = 17718866, "chrMtDNA" = 13794)
chr.names <-names(chr.length)

#Define the region of interest based on the binsize. This utilises the midpoint. Some modification to this definition of the bins might be 
#required if you want to look for a large region that is bigger then a bin. 
left_boundary<-as.numeric(query_region[1])-(as.numeric(query_region[4])/2)
right_boundary<-as.numeric(query_region[2])+(as.numeric(query_region[4])/2)
midpoint <-(left_boundary+right_boundary)/2

#Define an output name
output_name<-paste0(query_region[6],'_',query_region[4],'bins')

#Create a function that will run on each dataset, to create a matrix of intra chromosomal interactions. These outputs will then be used to graph my 
#viewpoint data
slid_bins<-function(input_table) {

input_name<-deparse(substitute(input_table))

#Output ID
output_ID<-paste0(query_region[6],'_',input_name,'_',query_region[4],'bins')

#Find all interactions from your reigon of interest
left_hits<-which(input_table[,1]==query_region[3]&input_table[,2]>left_boundary&input_table[,2]<right_boundary)
right_hits<-which(input_table[,3]==query_region[3]&input_table[,4]>left_boundary&input_table[,4]<right_boundary)

#Remove all in which both ends are in your region of interest
left_partner<-input_table[left_hits,4]
right_partner<-input_table[right_hits,2]

left_ROI<-left_partner[-which(left_partner>left_boundary&left_partner<right_boundary)]
right_ROI<-right_partner[-which(right_partner>left_boundary&right_partner<right_boundary)]

#Add both potential directions of inteaction together.
total_ROI<-c(left_ROI,right_ROI)
print('Region of interest defined')

#Counts are generated for each 10Kb window
counted_ROI<-table(floor(total_ROI/as.numeric(query_region[4])))

#Mainpulate the rex sites so they can be graphed 
pos<-rex_sites[1:17,2]/as.numeric(query_region[4])

#how many bins are there over the chr
bin_number<-chr.length[[query_region[3]]]/as.numeric(query_region[4])
full_table<-matrix(0,bin_number,2)
full_table[,1]<-1:bin_number
#get the distances that have values in the table
my_header<-as.numeric(names(counted_ROI))
#Put the values for the table in a dat matrix for every position.
for (i in 1:length(my_header)){
  index<-which(full_table[,1]==my_header[i])
  full_table[index,2]<-counted_ROI[i]
}

#Next need to create sliding average. 
sliding_bins<-matrix(0,(bin_number-2),2)
sliding_bins[,1]<-2:(bin_number-1)

for (i in 1:nrow(sliding_bins)){
  sliding_bins[i,2]<-(sum(full_table[i,2]+full_table[i+1,2], full_table[i+2,2]))/3
  }

dashpoint<-c(log10(max(sliding_bins))/3,log10(max(sliding_bins))/3+log10(max(sliding_bins))/20,log10(max(sliding_bins))/3+2*(log10(max(sliding_bins))/20))
assign(paste0(input_name,'sliding_bins'), sliding_bins)
assign(paste0(input_name,'full_table'),full_table)

output<-list(get(paste0(input_name,'sliding_bins')),get(paste0(input_name,'full_table')),dashpoint)
return(output)
}

#Lets use the function to create the matrices of interactions across chrX
N2B1_tables<-slid_bins(N2B1)
N2B2_tables<-slid_bins(N2B2)
SDC2B1_tables<-slid_bins(SDC2B1)
SDC2B2_tables<-slid_bins(SDC2B2)

N2B12015_tables<-slid_bins(N2B12015)
N2B22015_tables<-slid_bins(N2B22015)
#SDC2B12015_tables<-slid_bins(SDC2B12015)
#SDC2B22015_tables<-slid_bins(SDC2B22015)

#Names for my lists of matrices
datapoints_2017<-c('N2B1_tables','N2B2_tables','SDC2B1_tables','SDC2B2_tables')
datapoints_2015<-c('N2B12015_tables','N2B22015_tables')#,'SDC2B12015_tables','SDC2B22015_tables')

#Mainpulate the top rex sites so they can be graphed 
pos<-rex_sites[1:17,2]/as.numeric(query_region[4])

#define graph parameters
library(wesanderson)
col<-wes_palette("GrandBudapest2")

#Plot out the raw counts 2015
output1<-paste0(query_region[5],output_name,'_2015_raw_counts.pdf')

pdf(output1)
par(mfrow=c(2,2))
for(i in 1:4){
my_title<-strsplit(datapoints_2015[i],'_')[[1]][1]
plot(get(datapoints_2015[i])[[2]][,1],log10(get(datapoints_2015[i])[[2]][,2]),main=my_title,type='l', xaxt = "n", ylab='log10(counts per 10kb bin)', xlab='Chromosome position (10000 Kb)', xlim=c(0,seq(0,chr.length[[query_region[3]]]/10000,by=200)))
axis(1, at=seq(0,chr.length[[query_region[3]]]/10000,by=200), labels=seq(0,chr.length[[query_region[3]]]/10000,by=200))
if(query_region[3]=='chrX'){
text(pos+40, matrix(get(datapoints_2015[i])[[3]][3],1,17),cex=0.6, labels=rex_sites[1:17,5], srt=45)
segments(pos, matrix(get(datapoints_2015[i])[[3]][1],1,17),pos, y1 = matrix(get(datapoints_2015[i])[[3]][2],1,17), col=col[1], lwd=2)
}
segments(midpoint/as.numeric(query_region[4]), (datapoints_2015[i])[[3]][1]),midpoint/as.numeric(query_region[4]), (datapoints_2015[i])[[3]][1]), col=col[2], lwd=2)
text(midpoint/as.numeric(query_region[4])+40, (datapoints_2015[i])[[3]][3]),cex=0.6, labels='BAIT', srt=45)
}
dev.off()

output1<-paste0(query_region[5],output_name,'_2017_raw_counts.pdf')

pdf(output1)
par(mfrow=c(2,2))
for(i in 1:4){
my_title<-strsplit(datapoints_2017[i],'_')[[1]][1]
plot(get(datapoints_2017[i])[[2]][,1],log10(get(datapoints_2017[i])[[2]][,2]),main=my_title,type='l', xaxt = "n", ylab='log10(counts per 10kb bin)', xlab='Chromosome position (10000 Kb)', xlim=c(0,chr.length[[query_region[3]]]/10000))
axis(1, at=seq(0,chr.length[[query_region[3]]]/10000,by=200), labels=seq(0,chr.length[[query_region[3]]]/10000,by=200))
if(query_region[3]=='chrX'){
text(pos+40, matrix(get(datapoints_2017[i])[[3]][3],1,17),cex=0.6, labels=rex_sites[1:17,5], srt=45)
segments(pos, matrix(get(datapoints_2017[i])[[3]][1],1,17),pos, y1 = matrix(get(datapoints_2017[i])[[3]][2],1,17), col=col[1], lwd=2)
}
segments(midpoint/as.numeric(query_region[4]), (datapoints_2015[i])[[3]][1]),midpoint/as.numeric(query_region[4]), (datapoints_2015[i])[[3]][1]), col=col[2], lwd=2)
text(midpoint/as.numeric(query_region[4])+40, (datapoints_2015[i])[[3]][3]),cex=0.6, labels='BAIT', srt=45)
}
dev.off()


print('Raw counts plotted')


#Output the graph of sliding average.
output2<-paste0(query_region[5],output_name,'_2015_slidingwindow.pdf')

pdf(output2)
par(mfrow=c(2,1))
for(i in 1:2){
my_title<-strsplit(datapoints_2015[i],'_')[[1]][1]
plot(get(datapoints_2015[i])[[1]][,1],log10(get(datapoints_2015[i])[[1]][,2]),main=my_title, xaxt = "n",type='l', ylab='log10(counts per 10kb bin)', xlab='Chromosome position (10000 Kb)', xlim=c(0,chr.length[[query_region[3]]]/10000))
axis(1, at=seq(0,chr.length[[query_region[3]]]/10000,by=200), labels=seq(0,chr.length[[query_region[3]]]/10000,by=200))
if(query_region[3]=='chrX'){
text(pos+40, matrix(get(datapoints_2015[i])[[3]][3],1,17),cex=0.8, labels=rex_sites[1:17,5], srt=45)
segments(pos, matrix(get(datapoints_2015[i])[[3]][1],1,17),pos, y1 = matrix(get(datapoints_2015[i])[[3]][2],1,17), col=col[1], lwd=2)
}
segments(midpoint/as.numeric(query_region[4]), (datapoints_2015[i])[[3]][1]),midpoint/as.numeric(query_region[4]), (datapoints_2015[i])[[3]][1]), col=col[2], lwd=2)
text(midpoint/as.numeric(query_region[4])+40, (datapoints_2015[i])[[3]][3]),cex=0.6, labels='BAIT', srt=45)
}
dev.off()

output2<-paste0(query_region[5],output_name,'_2017_slidingwindow.pdf')

pdf(output2)
par(mfrow=c(2,1))
for(i in 1:2){
my_title<-strsplit(datapoints_2017[i],'_')[[1]][1]
plot(get(datapoints_2017[i])[[1]][,1],log10(get(datapoints_2017[i])[[1]][,2]),main=my_title, xaxt = "n",type='l', ylab='log10(counts per 10kb bin)', xlab='Chromosome position (10000 Kb)', xlim=c(0,chr.length[[query_region[3]]]/10000))
axis(1, at=seq(0,chr.length[[query_region[3]]]/10000,by=200), labels=seq(0,chr.length[[query_region[3]]]/10000,by=200))
if(query_region[3]=='chrX'){
text(pos+40, matrix(get(datapoints_2017[i])[[3]][3],1,17),cex=0.8, labels=rex_sites[1:17,5], srt=45)
segments(pos, matrix(get(datapoints_2017[i])[[3]][1],1,17),pos, y1 = matrix(get(datapoints_2017[i])[[3]][2],1,17), col=col[1], lwd=2)
}
segments(midpoint/as.numeric(query_region[4]), (datapoints_2015[i])[[3]][1]),midpoint/as.numeric(query_region[4]), (datapoints_2015[i])[[3]][1]), col=col[2], lwd=2)
text(midpoint/as.numeric(query_region[4])+40, (datapoints_2015[i])[[3]][3]),cex=0.6, labels='BAIT', srt=45)
}
dev.off()


print('Sliding window chart plotted')

#Lets deal with inter-chromosomal interactions now. 

#Create a function that will run on each dataset, to create a matrix of inter chromosomal interactions. These outputs will then be used to graph my 
#viewpoint data
slid_bins_inter<-function(input_table) {

input_name<-deparse(substitute(input_table))

#Output ID
output_ID<-paste0(query_region[6],'_',input_name,'_',query_region[4],'bins')

#Find all interactions from your reigon of interest
left_hits<-which(input_table[,1]==query_region[3]&input_table[,2]>left_boundary&input_table[,2]<right_boundary)
right_hits<-which(input_table[,3]==query_region[3]&input_table[,4]>left_boundary&input_table[,4]<right_boundary)


#Add both potential directions of inteaction together.
colnames(input_table)<-c('chr','pos','chr','pos')
total_ROI<-rbind(input_table[left_hits,c(3,4)],input_table[right_hits,c(1,2)])
print('Region of interest defined')

#Need to break down into individual chromosomes.
unique(total_ROI[,1])->inter_chrs
for(i in 1:length(inter_chrs)){
chr_specific<-which(total_ROI[,1]==inter_chrs[i])
assign(paste0(inter_chrs[i],'_interactors'),total_ROI[chr_specific,2])
}

#Counts are generated for each 10Kb window
for(i in 1:length(inter_chrs)){
assign(paste0(inter_chrs[i],'_counts'),table(floor(get(paste0(inter_chrs[i],'_interactors'))/as.numeric(query_region[4]))))
}

#how many bins are there over each chr
for(i in 1:length(inter_chrs)){
bin_number<-chr.length[[inter_chrs[i]]]/as.numeric(query_region[4])
full_table<-matrix(0,bin_number,2)
full_table[,1]<-1:bin_number
#get the distances that have values in the table
my_header<-as.numeric(names(get(paste0(inter_chrs[i],'_counts'))))
#Put the values for the table in a dat matrix for every position.
for (j in 1:length(my_header)){
  index<-which(full_table[,1]==my_header[j])
  full_table[index,2]<-get(paste0(inter_chrs[i],'_counts'))[i]
}

#Next need to create sliding average. 

sliding_bins<-matrix(0,(bin_number-2),2)
sliding_bins[,1]<-2:(bin_number-1)
if(bin_number>5){
for (j in 1:nrow(sliding_bins)){
  sliding_bins[j,2]<-(sum(full_table[j,2]+full_table[j+1,2], full_table[j+2,2]))/3
  }

assign(paste0(input_name,'_',inter_chrs[i],'_sliding_bins'), sliding_bins)
}
assign(paste0(input_name,'_',inter_chrs[i],'_full_table'),full_table)

if(inter_chrs[i]=='chrX'){
dashpoint<-c(log10(max(sliding_bins))/3,log10(max(sliding_bins))/3+log10(max(sliding_bins))/20,log10(max(sliding_bins))/3+2*(log10(max(sliding_bins))/20))
}

print(i)
}



output<-lapply(ls(pattern=(paste0(input_name,"_chr"))), get)
names(output)<-ls(pattern=paste0(input_name,"_chr"))

return(output)
}


#Use function to create lists of matrices

N2B1_tables<-slid_bins_inter(N2B1)
N2B2_tables<-slid_bins_inter(N2B2)
SDC2B1_tables<-slid_bins_inter(SDC2B1)
SDC2B2_tables<-slid_bins_inter(SDC2B2)

N2B12015_tables<-slid_bins_inter(N2B12015)
N2B22015_tables<-slid_bins_inter(N2B22015)
#SDC2B12015_tables<-slid_bins_inter(SDC2B12015)
#SDC2B22015_tables<-slid_bins_inter(SDC2B22015)


GRAPH THE OUTPUT


#Names for my lists of matrices
datapoints_2017<-c('N2B1_tables','N2B2_tables','SDC2B1_tables','SDC2B2_tables')
datapoints_2015<-c('N2B12015_tables','N2B22015_tables')#,'SDC2B12015_tables','SDC2B22015_tables')

#Mainpulate the top rex sites so they can be graphed 
pos<-rex_sites[1:17,2]/as.numeric(query_region[4])

#define graph parameters
library(wesanderson)
col<-wes_palette("GrandBudapest2")

#Plot out the raw counts 2015
output1<-paste0(query_region[5],output_name,'_2015_raw_counts.pdf')

pdf(output1)
par(mfrow=c(2,2))
for(i in 1:4){
my_title<-strsplit(datapoints_2015[i],'_')[[1]][1]
plot(get(datapoints_2015[i])[[2]][,1],log10(get(datapoints_2015[i])[[2]][,2]),main=my_title,type='l', xaxt = "n", ylab='log10(counts per 10kb bin)', xlab='Chromosome position (10000 Kb)', xlim=c(0,seq(0,chr.length[[query_region[3]]]/10000,by=200)))
axis(1, at=seq(0,chr.length[[query_region[3]]]/10000,by=200), labels=seq(0,chr.length[[query_region[3]]]/10000,by=200))
if(query_region[3]=='chrX'){
text(pos+40, matrix(get(datapoints_2015[i])[[3]][3],1,17),cex=0.6, labels=rex_sites[1:17,5], srt=45)
segments(pos, matrix(get(datapoints_2015[i])[[3]][1],1,17),pos, y1 = matrix(get(datapoints_2015[i])[[3]][2],1,17), col=col[1], lwd=2)
}
segments(midpoint/as.numeric(query_region[4]), (datapoints_2015[i])[[3]][1]),midpoint/as.numeric(query_region[4]), (datapoints_2015[i])[[3]][1]), col=col[2], lwd=2)
text(midpoint/as.numeric(query_region[4])+40, (datapoints_2015[i])[[3]][3]),cex=0.6, labels='BAIT', srt=45)
}
dev.off()







Sys.time()

print('All done! Woop woop!')
